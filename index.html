---
layout: index
title: System Rules
description: A collection of JUnit rules for testing code that uses java.lang.System.
---
<section id="overview">
    	<div class="row">
	    	<div class="col-md-4">
					<h2>System.getProperty(…)</h2>
					<p>When your test reads a system property, you have to set it before the test and
					restore its original value afterwards. Use the 
					<a href="#ClearSystemProperty">ClearSystemProperty</a> and
					<a href="#ProvideSystemProperty">ProvideSystemProperty</a> rules for this
					purpose.
				</div>
	    	<div class="col-md-4">
					<h2>System.setProperty(…)</h2>
					<p>When your test changes a system property, you should restore its original value
					after the test. The <a href="#RestoreSystemProperties">RestoreSystemProperties</a>
					rule does this for you.</p>
				</div>
	    	<div class="col-md-4">
					<h2>System.exit(…)</h2>
					<p>Use the <a href="#ExpectedSystemExit">ExpectedSystemExit</a> rule to test code that calls <code>System.exit(…).</code> Verify that
					<code>System.exit(…)</code> is called, verify the status code of this call or check assertions afterwards.</p>
				</div>
	    </div>
    	<div class="row">
	    	<div class="col-md-4">
					<h2>System.getSecurityManager()</h2>
					<p>Use the <a href="#ProvideSecurityManager">ProvideSecurityManager</a> rule to
					provide a special security manager for your test. The system's security manager is
					restored after the test.</p>
				</div>
	    </div>
    	<div class="row">
	    	<div class="col-md-4">
					<h2>System.err</h2>
					<p>Use the <a href="#StandardErrorStreamLog">StandardErrorStreamLog</a> rule
					to capture and verify the text, that your test writes to <code>System.err.</code></p>
				</div>
	    	<div class="col-md-4">
					<h2>System.in</h2>
					<p>Use the <a href="#TextFromStandardInputStream">TextFromStandardInputStream</a> rule
					to provide text, that your test reads from <code>System.in.</code></p>
				</div>
	    	<div class="col-md-4">
					<h2>System.out</h2>
					<p>Use the <a href="#StandardErrorStreamLog">StandardOutputStreamLog</a> rule
					to capture and verify the text, that your test writes to <code>System.out.</code></p>
				</div>
	    </div>
		</section>

		<section id="getProperty">
			<div class="page-header">
				<h1>Usage</h1>
			</div>

			<div class="alert alert-warning">
				<strong>Advice:</strong>
				System Rules needs at least <strong>JUnit 4.9.</strong>
			</div>

	<section>
		<p>All examples below are using the <code>@Rule</code> annotation,
		but the rules can be used with the <code>@ClassRule</code>
		annotation, too.</p>
	</section>

			<section id="ClearSystemProperty">
				<h3>Clear Properties</h3>
				<p>The ClearSystemProperty rule deletes the property before the test
				and restores the original value of the property when the test is
				finished.</p>
				{% highlight java %}public void MyTest {
	@Rule
	public final ClearSystemProperty myPropertyIsCleared
	 = new ClearSystemProperty("MyProperty");

	@Test
	public void overrideProperty() {
		assertNull(System.getProperty("MyProperty"));
	}
}{% endhighlight %}
			</section>
				
			<section id="ProvideSystemProperty">
				<h3>Provide Properties</h3>
				<p>The ProvideSystemProperty rule provides an arbitrary value for a
				system property to a test. After the test the original value is
				restored.</p>
				{% highlight java %}public void MyTest {
	@Rule
	public final ProvideSystemProperty myPropertyHasMyValue
	 = new ProvideSystemProperty("MyProperty", "MyValue");

	@Rule
	public final ProvideSystemProperty otherPropertyIsMissing
	 = new ProvideSystemProperty("OtherProperty", null);

	@Test
	public void overrideProperty() {
		assertEquals("MyValue", System.getProperty("MyProperty"));
		assertNull(System.getProperty("OtherProperty"));
	}
}{% endhighlight %}
				<p>You could also use a single instance of the rule to achieve the
				same effect:</p>
				{% highlight java %}public void MyTest {
	@Rule
	public final ProvideSystemProperty properties
	 = new ProvideSystemProperty("MyProperty", "MyValue").and("OtherProperty", null);

	@Test
	public void overrideProperty() {
		assertEquals("MyValue", System.getProperty("MyProperty"));
		assertNull(System.getProperty("OtherProperty"));
	}
}{% endhighlight %}

				<p>You can use a properties file to supply properties for the
		ProvideSystemProperty rule. The file can be from the file system or the
		class path. In the first case use</p>
				{% highlight java %}@Rule
public final ProvideSystemProperty properties
 = ProvideSystemProperty.fromFile("/home/myself/example.properties");{% endhighlight %}

				<p>and in the second case use</p>
				{% highlight java %}@Rule
public final ProvideSystemProperty properties
 = ProvideSystemProperty.fromResource("example.properties");{% endhighlight %}
			</section>

			<section id="RestoreSystemProperties">
				<h3>Restore Properties</h3>
				<p>The RestoreSystemProperties rule restores the original value of
				the property when the test is finished.</p>
				{% highlight java %}public void MyTest {
	@Rule
	public final RestoreSystemProperties restoreSystemProperties
	 = new RestoreSystemProperties("MyProperty");

	@Test
	public void overrideProperty() {
		//after the test the original value of "MyProperty" will be restored.
		System.setProperty("MyProperty", "other value");
		...
	}
}{% endhighlight %}
			</section>
    
			<section id="StandardErrorStreamLog">
				<h3>System.err and System.out</h3>
				<p>The <code>StandardErrorStreamLog</code> and
				<code>StandardOutputStreamLog</code> rules help you to create tests
				for classes that write to <code>System.err</code> or
				<code>System.out</code>. They are recording everything written to
				<code>System.err</code> or <code>System.out</code>. The text is
				available by calling getLog().</p>
				{% highlight java %}public void MyTest {
	@Rule
	public final StandardErrorStreamLog log = new StandardErrorStreamLog();

	@Test
	public void writesTextToSystemErr() {
		System.err.print("hello world");
		assertEquals("hello world", log.getLog());
	}
}{% endhighlight %}

    		{% highlight java %}public void MyTest {
	@Rule
	public final StandardOutputStreamLog log = new StandardOutputStreamLog();

	@Test
	public void writesTextToSystemOut() {
		System.out.print("hello world");
		assertEquals("hello world", log.getLog());
	}
}{% endhighlight %}
				<p>The log can be cleared if you want to discard some text that has
				been written to the log.</p>
				{% highlight java %}public void MyTest {
	@Rule
	public final StandardErrorStreamLog log = new StandardErrorStreamLog();

	@Test
	public void writesTextToSystemErr() {
		System.err.print("hello world");
		log.clear().
		System.err.print("foo");
		assertEquals("foo", log.getLog());
	}
}{% endhighlight %}

    		{% highlight java %}public void MyTest {
	@Rule
	public final StandardOutputStreamLog log = new StandardOutputStreamLog();

	@Test
	public void writesTextToSystemOut() {
		System.out.print("hello world");
		log.clear().
		System.out.print("foo");
		assertEquals("foo", log.getLog());
	}
}{% endhighlight %}
				<p>The output is still written to <code>System.err</code> and
				<code>System.out</code>. In general this is not necessary. Avoiding
				the output may speed up the test and reduce the clutter on the
				commandline. You can disable the output by creating the rules with
				the flag `LOG_ONLY`.</p>
				{% highlight java %}@Rule
public final StandardErrorStreamLog log = new StandardErrorStreamLog(LOG_ONLY);{% endhighlight %}

				{% highlight java %}@Rule
public final StandardOutputStreamLog log = new StandardOutputStreamLog(LOG_ONLY);{% endhighlight %}
			</section>

			<section id="TextFromStandardInputStream">
				<h3>System.in</h3>
				<p>The <code>TextFromStandardInputStream</code> rule helps you
				to create tests for classes which read from
				<code>System.in.</code> You specify the text provided by
				<code>System.in</code>, by calling
				<code>provideText(String).</code>
				The example's class under test reads two numbers from
				<code>System.in</code> and calculates the sum of these numbers.</p>

				<h4>Class Under Test</h4>
				{% highlight java %}import java.util.Scanner;

public class Summarize {
  public static int sumOfNumbersFromSystemIn() {
    Scanner scanner = new Scanner(System.in);
    int firstSummand = scanner.nextInt();
    int secondSummand = scanner.nextInt();
    return firstSummand + secondSummand;
  }
}{% endhighlight %}

				<h4>Test</h4>
				{% highlight java %}import static org.junit.Assert.*;
import static org.junit.contrib.java.lang.system.TextFromStandardInputStream.*;

import org.junit.Rule;
import org.junit.Test;
import org.junit.contrib.java.lang.system.TextFromStandardInputStream;

public class SummarizeTest {
  @Rule
  public final TextFromStandardInputStream systemInMock
    = emptyStandardInputStream();

  @Test
  public void summarizesTwoNumbers() {
    systemInMock.provideText("1\n2\n");
    assertEquals(3, Summarize.sumOfNumbersFromSystemIn());
  }
}{% endhighlight %}
			</section>

			<section id="ExpectedSystemExit">
				<h3>System.exit()</h3>
				<p>If your code calls <code>System.exit(),</code> then your test
				stops and doesn't finish. The <code>ExpectedSystemExit</code>
				rule allows in-test specification of expected
				<code>System.exit()</code> calls. Furthermore you cannot use
				JUnit's assert methods because of the abnormal termination of
				your code. As a substitute you can provide an
				<code>Assertion</code> object to the
				<code>ExpectedSystemExit</code> rule.</p>

				<p>Some care must be taken if your system under test creates a
				new thread and this thread calls <code>System.exit()</code>. In
				this case you have to ensure that the test does not finish
				before <code>System.exit()</code> is called.</p>

				<h4>Class Under Test</h4>
				{% highlight java %}public class AppWithExit {
  public static String message;

  public static void doSomethingAndExit() {
    message = "exit ...";
    System.exit(1);		
  }

  public static void doNothing() {
  }
}{% endhighlight %}

				<h4>Test</h4>
				{% highlight java %}public void AppWithExitTest {
  @Rule
  public final ExpectedSystemExit exit = ExpectedSystemExit.none();

  @Test
  public void exits() {
    exit.expectSystemExit();
    AppWithExit.doSomethingAndExit();
  }

  @Test
  public void exitsWithStatusCode1() {
    exit.expectSystemExitWithStatus(1);
    AppWithExit.doSomethingAndExit();
  }

  @Test
  public void writesMessage() {
    exit.expectSystemExitWithStatus(1);
    exit.checkAssertionAfterwards(new Assertion() {
      public void checkAssertion() {
        assertEquals("exit ...", AppWithExit.message);
      }
    });
    AppWithExit.doSomethingAndExit();
  }

  @Test
  public void systemExitWithStatusCode1() {
    exit.expectSystemExitWithStatus(1);
    AppWithExit.doSomethingAndExit();
  }

  @Test
  public void noSystemExit() {
    AppWithExit.doNothing();
    //passes
  }
}{% endhighlight %}
			</section>

			<section id="ProvideSecurityManager">
				<h3>Security Manager</h3>
				<p>If you need a special security manager to test your code, you may
				provide it by using the ProvideSecurityManager rule. This rule
				replaces the system's security manager with yours throughout the
				test</p>
				{% highlight java %}public void MyTest {
	private final MySecurityManager securityManager
	 = new MySecurityManager();

	@Rule
	public final ProvideSecurityManager provideSecurityManager
	 = new ProvideSecurityManager(securityManager);

	@Test
	public void overrideProperty() {
		assertEquals(securityManager, System.getSecurityManager());
	}
}{% endhighlight %}
			</section>
</section>

<h2>Authors</h2>
      <p>Marc Philipp (mail@marcphilipp.de)
<br/>Stefan Birkner (mail@stefan-birkner.de)
<br/>      </p>
    

    
<h2>Contact</h2>
<p>Stefan Birkner (mail@stefan-birkner.de)</p>
