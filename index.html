---
layout: index
title: System Rules
description: A collection of JUnit rules for testing code that uses java.lang.System.
---
<section id="overview">
  <p>The scope of System Rules is divided into five sections.</p>

  <h2>System.out, System.err and System.in</h2>
  <p>Command-line applications read from the command-line and write to
  it. Use <a href="#SystemErrAndOutRule">SystemErrRule</a>,
  <a href="#SystemErrAndOutRule">SystemOutRule</a> and
  <a href="#TextFromStandardInputStream">TextFromStandardInputStream</a> to
  provide the input text and verify the output.</p>
  <p>Applications sometimes unintentionally write to <code>System.out</code>
  or <code>System.err</code>. Ensure that this does not happen by using
  <a href="#disallow-write">DisallowWriteToSystemOut</a> and
  and <a href="#disallow-write">DisallowWriteToSystemErr</a>.

  <h2>System.exit</h2>
  <p>Use the <a href="#ExpectedSystemExit">ExpectedSystemExit</a> rule to
  test code that calls <code>System.exit(…).</code> Verify that
  <code>System.exit(…)</code> is called, verify the status code of this
  call or check assertions the application terminated.</p>

  <h2>System Properties</h2>
  <p>If your test deals with system properties, you have to set them and
  restore them after the test. Use the
  <a href="#ClearSystemProperties">ClearSystemProperties</a>,
  <a href="#ProvideSystemProperty">ProvideSystemProperty</a> and
  <a href="#RestoreSystemProperties">RestoreSystemProperties</a> rules for
  this purpose.

  <h2>Environment Variables</h2>
  <p>If your test needs to set an environment variable then use the
  <a href="#EnvironmentVariables">EnvironmentVariables</a> rule.</p>

  <h2>Security Managers</h2>
  <p>Use the <a href="#ProvideSecurityManager">ProvideSecurityManager</a>
  rule to provide a specific security manager for your test. The system's
  security manager is restored after the test.</p>
</section>

			<div class="page-header">
				<h1>Usage</h1>
			</div>

			<div class="alert alert-warning">
				<strong>Advice:</strong>
				System Rules needs at least <strong>JUnit 4.9.</strong>
			</div>

	<section>
		<p>All examples below are using the <code>@Rule</code> annotation,
		but the rules can be used with the <code>@ClassRule</code>
		annotation, too.</p>
	</section>

			<section id="ClearSystemProperties">
				<h3>Clear Properties</h3>
				<p>The ClearSystemProperties rule deletes the property before the test
				and restores the original value of the property when the test is
				finished.</p>
				{% highlight java %}public void MyTest {
	@Rule
	public final ClearSystemProperties myPropertyIsCleared
	 = new ClearSystemProperties("MyProperty");

	@Test
	public void overrideProperty() {
		assertNull(System.getProperty("MyProperty"));
	}
}{% endhighlight %}
			</section>

			<section id="ProvideSystemProperty">
				<h3>Provide Properties</h3>
				<p>The ProvideSystemProperty rule provides an arbitrary value for a
				system property to a test. After the test the original value is
				restored.</p>
				{% highlight java %}public void MyTest {
	@Rule
	public final ProvideSystemProperty myPropertyHasMyValue
	 = new ProvideSystemProperty("MyProperty", "MyValue");

	@Rule
	public final ProvideSystemProperty otherPropertyIsMissing
	 = new ProvideSystemProperty("OtherProperty", null);

	@Test
	public void overrideProperty() {
		assertEquals("MyValue", System.getProperty("MyProperty"));
		assertNull(System.getProperty("OtherProperty"));
	}
}{% endhighlight %}
				<p>You could also use a single instance of the rule to achieve the
				same effect:</p>
				{% highlight java %}public void MyTest {
	@Rule
	public final ProvideSystemProperty properties
	 = new ProvideSystemProperty("MyProperty", "MyValue").and("OtherProperty", null);

	@Test
	public void overrideProperty() {
		assertEquals("MyValue", System.getProperty("MyProperty"));
		assertNull(System.getProperty("OtherProperty"));
	}
}{% endhighlight %}

				<p>You can use a properties file to supply properties for the
		ProvideSystemProperty rule. The file can be from the file system or the
		class path. In the first case use</p>
				{% highlight java %}@Rule
public final ProvideSystemProperty properties
 = ProvideSystemProperty.fromFile("/home/myself/example.properties");{% endhighlight %}

				<p>and in the second case use</p>
				{% highlight java %}@Rule
public final ProvideSystemProperty properties
 = ProvideSystemProperty.fromResource("example.properties");{% endhighlight %}
			</section>

			<section id="RestoreSystemProperties">
				<h3>Restore Properties</h3>
				<p>The RestoreSystemProperties rule undoes changes of all system properties when the test finishes (whether it passes or fails).</p>
				{% highlight java %}public void MyTest {
	@Rule
	public final RestoreSystemProperties restoreSystemProperties
	 = new RestoreSystemProperties();

	@Test
	public void overrideProperty() {
		//after the test the original value of "MyProperty" will be restored.
		System.setProperty("MyProperty", "other value");
		...
	}
}{% endhighlight %}
			</section>

<section id="SystemErrAndOutRule">
	<h3>System.err and System.out</h3>
	<p>The <code>SystemErrRule</code> and the <code>SystemOutRule</code>
	help you to create tests for classes that write to
	<code>System.err</code> or <code>System.out</code>. They can record
	everything written to <code>System.err</code> or <code>System.out</code>.
	The text is available by calling <code>getLog()</code>.</p>
	{% highlight java %}public void MyTest {
	@Rule
	public final SystemErrRule systemErrRule = new SystemErrRule().enableLog();

	@Test
	public void writesTextToSystemErr() {
		System.err.print("hello world");
		assertEquals("hello world", systemErrRule.getLog());
	}
}{% endhighlight %}

    	{% highlight java %}public void MyTest {
	@Rule
	public final SystemOutRule systemOutRule = new SystemOutRule().enableLog();

	@Test
	public void writesTextToSystemOut() {
		System.out.print("hello world");
		assertEquals("hello world", systemOutRule.getLog());
	}
}{% endhighlight %}
	<p>If you verify logs that contain line separators than the separators
	are different (e.g. Linux: <code>\n</code>, Windows: <code>\r\n</code>).
	Use <code>getLogWithNormalizedLineSeparator()</code> for a log that
	always has the line separator <code>\n</code>.</p>
	{% highlight java %}public void MyTest {
	@Rule
	public final SystemErrRule systemErrRule = new SystemErrRule().enableLog();

	@Test
	public void writesTextToSystemErr() {
		System.err.print(String.format("hello world%n)");
		assertEquals("hello world\n", systemErrRule.getLog());
	}
}{% endhighlight %}

    	{% highlight java %}public void MyTest {
	@Rule
	public final SystemOutRule systemOutRule = new SystemOutRule().enableLog();

	@Test
	public void writesTextToSystemOut() {
		System.out.print(String.format("hello world%n)");
		assertEquals("hello world\n", systemOutRule.getLog());
	}
}{% endhighlight %}

	<p>The log can be cleared if you want to discard some text that has been
	written to the log.</p>
	{% highlight java %}public void MyTest {
	@Rule
	public final SystemErrRule systemErrRule = new SystemErrRule().enableLog();

	@Test
	public void writesTextToSystemErr() {
		System.err.print("hello world");
		systemErrRule.clear().
		System.err.print("foo");
		assertEquals("foo", systemErrRule.getLog());
	}
}{% endhighlight %}

    	{% highlight java %}public void MyTest {
	@Rule
	public final SystemOutRule systemOutRule = new SystemOutRule().enableLog();

	@Test
	public void writesTextToSystemOut() {
		System.out.print("hello world");
		systemOutRule.clear().
		System.out.print("foo");
		assertEquals("foo", systemOutRule.getLog());
	}
}{% endhighlight %}
	<p>The output is still written to <code>System.err</code> and
	<code>System.out</code>. In general this is not necessary. Avoiding
	the output may speed up the test and reduce the clutter on the
	commandline. You can disable the output by calling <code>mute()</code>.
	{% highlight java %}@Rule
public final SystemErrRule systemErrRule = new SystemErrRule().mute();{% endhighlight %}

				{% highlight java %}@Rule
public final SystemOutRule systemOutRule = new SystemOutRule().mute();{% endhighlight %}
	<p>Muting and logging can be combined.</p>
	{% highlight java %}@Rule
public final SystemErrRule systemErrRule = new SystemErrRule().enableLog().mute();{% endhighlight %}

				{% highlight java %}@Rule
public final SystemOutRule systemOutRule = new SystemOutRule().enableLog().mute();{% endhighlight %}
	<p>In case of a failed test it is sometimes helpful to see the output.
	This is when the method <code>muteForSuccessfulTests()</code> comes
	into play.</p>
	{% highlight java %}@Rule
public final SystemErrRule systemErrRule = new SystemErrRule().muteForSuccessfulTests();{% endhighlight %}

				{% highlight java %}@Rule
public final SystemOutRule systemOutRule = new SystemOutRule().muteForSuccessfulTests();{% endhighlight %}
</section>

			<section id="TextFromStandardInputStream">
				<h3>System.in</h3>
				<p>The <code>TextFromStandardInputStream</code> rule helps you
				to create tests for classes which read from
				<code>System.in.</code> You specify the lines provided by
				<code>System.in</code>, by calling
				<code>provideLines(String...).</code>
				The example's class under test reads two numbers from
				<code>System.in</code> and calculates the sum of these numbers.</p>

				<h4>Class Under Test</h4>
				{% highlight java %}import java.util.Scanner;

public class Summarize {
  public static int sumOfNumbersFromSystemIn() {
    Scanner scanner = new Scanner(System.in);
    int firstSummand = scanner.nextInt();
    int secondSummand = scanner.nextInt();
    return firstSummand + secondSummand;
  }
}{% endhighlight %}

				<h4>Test</h4>
				{% highlight java %}import static org.junit.Assert.*;
import static org.junit.contrib.java.lang.system.TextFromStandardInputStream.*;

import org.junit.Rule;
import org.junit.Test;
import org.junit.contrib.java.lang.system.TextFromStandardInputStream;

public class SummarizeTest {
  @Rule
  public final TextFromStandardInputStream systemInMock
    = emptyStandardInputStream();

  @Test
  public void summarizesTwoNumbers() {
    systemInMock.provideLines("1", "2");
    assertEquals(3, Summarize.sumOfNumbersFromSystemIn());
  }
}{% endhighlight %}

				<p>If you want to test that your class under test handles exception correctly then you can tell <code>TextFromStandardInputStream</code> to throw an exception after all characters have been read.</p>

				{% highlight java %}systemInMock.throwExceptionOnInputEnd(new IOException());{% endhighlight %}
				<p>or</p>

				{% highlight java %}systemInMock.throwExceptionOnInputEnd(new RuntimeException());{% endhighlight %}
			</section>

<section id="disallow-write">
  <h3>Disallow write to System.out and System.err</h3>
  <p>The rules <code>DisallowWriteToSystemErr</code> and
  <code>DisallowWriteToSystemOut</code> let tests fail if they try to write to
  <code>System.err</code> or <code>System.out</code>. The rules are a nice
  replacement for static code analysis because they cover external libraries,
  too.</p>

  {% highlight java %}public class MyTest {
  @Rule
  public final DisallowWriteToSystemErr disallowWriteToSystemErr
    = new DisallowWriteToSystemErr();

  @Test
  public void this_test_fails() {
    System.err.println("some text");
  }
}{% endhighlight %}

  {% highlight java %}public class MyTest {
  @Rule
  public final DisallowWriteToSystemOut disallowWriteToSystemOut
    = new DisallowWriteToSystemOut();

  @Test
  public void this_test_fails() {
    System.out.println("some text");
  }
}{% endhighlight %}
</section>
			<section id="ExpectedSystemExit">
				<h3>System.exit()</h3>
				<p>If your code calls <code>System.exit(),</code> then your test
				stops and doesn't finish. The <code>ExpectedSystemExit</code>
				rule allows in-test specification of expected
				<code>System.exit()</code> calls. Furthermore you cannot use
				JUnit's assert methods because of the abnormal termination of
				your code. As a substitute you can provide an
				<code>Assertion</code> object to the
				<code>ExpectedSystemExit</code> rule.</p>

				<p>Some care must be taken if your system under test creates a
				new thread and this thread calls <code>System.exit()</code>. In
				this case you have to ensure that the test does not finish
				before <code>System.exit()</code> is called.</p>

				<h4>Class Under Test</h4>
				{% highlight java %}public class AppWithExit {
  public static String message;

  public static void doSomethingAndExit() {
    message = "exit ...";
    System.exit(1);
  }

  public static void doNothing() {
  }
}{% endhighlight %}

				<h4>Test</h4>
				{% highlight java %}public void AppWithExitTest {
  @Rule
  public final ExpectedSystemExit exit = ExpectedSystemExit.none();

  @Test
  public void exits() {
    exit.expectSystemExit();
    AppWithExit.doSomethingAndExit();
  }

  @Test
  public void exitsWithStatusCode1() {
    exit.expectSystemExitWithStatus(1);
    AppWithExit.doSomethingAndExit();
  }

  @Test
  public void writesMessage() {
    exit.expectSystemExitWithStatus(1);
    exit.checkAssertionAfterwards(new Assertion() {
      public void checkAssertion() {
        assertEquals("exit ...", AppWithExit.message);
      }
    });
    AppWithExit.doSomethingAndExit();
  }

  @Test
  public void systemExitWithStatusCode1() {
    exit.expectSystemExitWithStatus(1);
    AppWithExit.doSomethingAndExit();
  }

  @Test
  public void noSystemExit() {
    AppWithExit.doNothing();
    //passes
  }
}{% endhighlight %}
			</section>

<section id="EnvironmentVariables">
  <h3>Environment Variables</h3>
  <p>If you need to set an environment variable then use the
  <code>EnvironmentVariables</code> rule. It does all the tedious work for
  setting environment variables and reverts your changes after the test.</p>
  {% highlight java %}public void EnvironmentVariablesTest {
  @Rule
  public final EnvironmentVariables environmentVariables
    = new EnvironmentVariables();

  @Test
  public void setEnvironmentVariable() {
    environmentVariables.set("name", "value");
    assertEquals("value", System.getenv("name"));
  }
}{% endhighlight %}
</section>

			<section id="ProvideSecurityManager">
				<h3>Security Manager</h3>
				<p>If you need a special security manager to test your code, you may
				provide it by using the ProvideSecurityManager rule. This rule
				replaces the system's security manager with yours throughout the
				test</p>
				{% highlight java %}public void MyTest {
	private final MySecurityManager securityManager
	 = new MySecurityManager();

	@Rule
	public final ProvideSecurityManager provideSecurityManager
	 = new ProvideSecurityManager(securityManager);

	@Test
	public void overrideProperty() {
		assertEquals(securityManager, System.getSecurityManager());
	}
}{% endhighlight %}
</section>

<h2>Authors</h2>
      <p>Marc Philipp (mail@marcphilipp.de)
<br/>Stefan Birkner (mail@stefan-birkner.de)
<br/>      </p>



<h2>Contact</h2>
<p>Stefan Birkner (mail@stefan-birkner.de)</p>
